/**
 * Avery Hall
 * 10/27/2019
 * https://open.kattis.com/problems/incognito
 *
 * Incognito: The purpose of this program is to take in a list of attributes, used by spies,
 * to determine the total number of unique disguises that could be made using them. Input will
 * always consist of the first line being the number of test cases tc, followed by tc sets of lines in the form:
 *
 * an integer n (0 <= n <= 30)
 * n lines with two strings separated by a space, the strings being the name and category of an attribute, respectively
 *
 * Additionally, each string will be made of 1 to 20 lowercase characters
 */

// Note: This problem is essentially just asking, given all of these different sets of attributes (or spy-clothes), how
// many unique outfits can I make it I chose AT MOST 1 attribute from each set? So really it is just a combination
// problem using the formula: a!/r!(a-r)! where r=1, resulting in 'a' possible choices from each set at any given time.
// Now we have to generate EVERY subset of possible category combinations of n categories, resulting in (2^n)-1 subsets
// that each represent the categories being chosen from at any given time to make a unique outfit.
//
// Thus, we determine the total number of unique disguises by: taking each subset of categories and multiplying the
// elements of those sets together (because each element is a choice we are making with the other elements of the set at
// the same time), and adding that result to Disguise combinations of other subsets.


// Import Statement for ArrayList, Scanner, Hashtable, etc.
import java.util.*;

public class IncognitoIsNeato {

    // METHOD FOR DETERMINING THE REMAINING DISGUISES THAT CAN BE MADE USING THE CATEGORIES OF SIZE > 1
    // Originally this method was going to calculate the total number of disguises that could be made by all of the
    // attributes at one time by generating EVERY subclass of possible categories and then adding the combinations
    // together, which takes (2^n)-1 time, where n is the number of categories entered. Naturally though,
    // with the possibility of n ~= 30 (where every attribute could be in a different category), the number of
    // subclasses generated by this method could get very high. Thus, I think it should be faster to separate
    // attributes that are in a category of size 1 and calculate those separately, then add the results.
    private static int calculateRemainingDisguises(Hashtable<String,Integer> D, ArrayList<String> C)
    {

        int n = C.size();       //Originally this was D.size() but no need to make n uneccessarily large
        int numUniqueDis = 0;

        for(int i = 1; i < (1 << n); i++) {

            int total = 1;

            for(int j = 0; j < n; j++) { if ((i & (1<<j)) > 0) { total *= D.get( C.get(j) ); } }

            numUniqueDis += total;
        }

        return numUniqueDis;

    }



    // MAIN METHOD
    public static void main(String[] args) {

        //Initialize Scanner
        Scanner sc = new Scanner(System.in);

        //Initialize variables for number of test cases, lines in each test case (n), and unique disguises, respectively.
        int tc = Integer.parseInt(sc.nextLine());
        int n = 0;
        int numUniqueDisguises = 0;

        // Variables for Data Structures
        String[] Input;                 //String[] Attributes; (Optional)
        ArrayList<String> Categories;
        Hashtable<String,Integer> Disguises;



        // For each test case
        for(int i = 0; i < tc; i++) {

            // Scan next line to determine number of attributes in the current test case and
            // create New ArrayList and Hashtable for Category and Disguise information.
            n = Integer.parseInt(sc.nextLine());    //Attributes = new String[n]; (Optional)
            Categories = new ArrayList<>();
            Disguises = new Hashtable<>();

            // For each line in test case
            for (int j = 0; j < n; j++) {

                // Spit line, assign the category info to String category.
                Input = sc.nextLine().split(" ");       //String attribute = Input[0]; (Optional)
                String category = Input[1];                   //Attributes[j] = attribute; (Optional)

                // Checks if the category is already in the hashtable. If so, adds one to value. Else, adds category to
                // value.
                if(!Disguises.containsKey(category)) { Disguises.put(category, 1); Categories.add(category); }
                else { Disguises.replace(category, Disguises.get(category) + 1); }

            }


            //
//            ArrayList<String> SmallCategories = new ArrayList<>();
//            for( String cat : Disguises.keySet()) {
//                if (Disguises.get(cat) == 1) {
//                    System.out.println(cat);
//                }
//            }

            //TEST
//            System.out.println(Categories);
//            System.out.println(Disguises.toString());

            //Calculate the number of unique disguises using Set Mathematics and Bit Logic
            numUniqueDisguises += calculateRemainingDisguises(Disguises,Categories);

            //Output the results of the current test to Standard Output
            System.out.println(numUniqueDisguises);

        }

    }
}



// OLD CODE
//            for(String category : Categories) { numUnigueDisguises += Disguises.get(category);}
//            for(int j = 2; j <= Categories.size(); j++){}
//            System.out.println(101 << 3);
//            System.out.println((101 << 3) & (11 << 5));



//            for (int j = 2; j <= Categories.length; j++) {
//                int numCombinations = 1;
//                for(int k = 0; k < Categories.length - j; k++) {
//                    numCombinations *= Disguises.get();
//                }
//            }